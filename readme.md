# 排序算法

## 归并排序

没太搞懂，回头再继续研究一下，脑子一团浆糊

## 线性排序

1.线性排序算法包括桶排序、计数排序、基数排序。

2.线性排序算法的时间复杂度为O(n)。

3.此3种排序算法都不涉及元素之间的比较操作，是非基于比较的排序算法。

4.对排序数据的要求很苛刻，重点掌握此3种排序算法的适用场景

### 桶排序

#### 算法原理
- 将要排序的数据分到几个有序的桶里，每个桶里的数据再单独进行快速排序。
- 桶内排完序之后，再把每个桶里的数据按照顺序依次取出，组成的序列就是有序的了。

#### 使用条件
- 要排序的数据需要很容易就能划分成m个桶，并且桶与桶之间有着天然的大小顺序。
- 数据在各个桶之间分布是均匀的。

#### 适用场景
- 桶排序比较适合用在**外部排序**中
> 外部排序就是数据存储在外部磁盘且数据量大，但内存有限无法将整个数据全部加载到内存中。

#### 应用案例

1）需求描述：

有10GB的订单数据，需按订单金额（假设金额都是正整数）进行排序
但内存有限，仅几百MB

2）解决思路：

扫描一遍文件，看订单金额所处数据范围，比如1元-10万元，那么就分100个桶。
第一个桶存储金额1-1000元之内的订单，第二个桶存1001-2000元之内的订单，依次类推。
每个桶对应一个文件，并按照金额范围的大小顺序编号命名（00，01，02，…，99）。
将100个小文件依次放入内存并用快排排序。
所有文件排好序后，只需按照文件编号从小到大依次读取每个小文件并写到大文件中即可。

3）注意点：若单个文件无法全部载入内存，则针对该文件继续按照前面的思路进行处理即可。

### 计数排序

#### 算法原理
- 计数其实就是桶排序的一种特殊情况。
- 当要排序的n个数据所处范围并不大时，比如最大值为k，则分成k个桶
- 每个桶内的数据值都是相同的，就省掉了桶内排序的时间。

#### 使用条件
- 只能用在数据范围不大的场景中，若数据范围k比要排序的数据n大很多，就不适合用计数排序；
    > 因为是使用空间换时间的方式,空间是有限的
- 计数排序只能给非负整数排序，其他类型需要在不改变相对大小情况下，转换为非负整数；
    > 因为数组下标不能为负数
    >
    > 比如如果考试成绩精确到小数后一位，就需要将所有分数乘以10，转换为整数。

### 基数排序
#### 算法原理（以排序10万个手机号为例来说明）
- 将所有待比较数值（正整数）统一为同样的数位长度，数位较短的数前面补零。
- 然后，从最低位开始，依次进行一次排序。这样从最低位排序一直到最高位排序完成以后, 数列就变成一个有序序列。
    > 比如:比较两个手机号码a，b的大小，如果在前面几位中a已经比b大了，那后面几位就不用看了。
     借助稳定排序算法的思想，可以先按照最后一位来排序手机号码，然后再按照倒数第二位来重新排序，以此类推，最后按照第一个位重新排序。
     经过11次排序后，手机号码就变为有序的了。
     每次排序有序数据范围较小，可以使用桶排序或计数排序来完成。

#### 使用条件
- 要求数据可以分割独立的“位”来比较；
- 位之间由递进关系，如果a数据的高位比b数据大，那么剩下的地位就不用比较了；
- 每一位的数据范围不能太大，要可以用线性排序，否则基数排序的时间复杂度无法做到O(n)。

## 排序总结

|  | 时间复杂度 | 是否稳定排序 | 是否原地排序 |
| :---: | :---: | :---: | :---: |
| 冒泡排序 | O(n²)            | ✔ | ✔ |
| 插入排序 | O(n²)            | ✔ | ✔ |
| 选择排序 | O(n²)            | ✘ | ✔ |
| 快速排序 | O(nlogn)         | ✘ | ✔ |
| 归并排序 | O(nlogn)         | ✔ | ✘ |
| 计数排序 | O(n+k)k是数据范围  | ✔ | ✘ |
| 桶排序 | O(n)               | ✔ | ✘ |
| 基数排序 | O(dn)d是维度      | ✔ | ✘ |

# 查找算法

## 二分查找
  > 二分查找针对的是一个有序的数据集合，每次通过跟区间中间的元素对比，
  将待查找的区间缩小为之前的一半，直到找到要查找的元素，或者区间缩小为0
  
### 优点
- 时间复杂度低: O(logn)
- 省内存(对比散列表,二叉树)

### 使用条件
- 二分查找依赖的是顺序表结构，即**数组**。
- 二分查找针对的是有序数据，因此只能用在插入、删除操作不频繁，**一次排序多次查找**的场景中。
- **数据量太小**不适合二分查找，与直接遍历相比效率提升不明显。
    > 但有一个例外，就是数据之间的比较操作非常费时，比如数组中存储的都是
    长度超过300的字符串，那这是还是尽量减少比较操作使用二分查找吧。
- **数据量太大**也不是适合用二分查找，因为数组需要连续的空间，若数据量太大，往往找不到存储如此大规模数据的连续内存空间。